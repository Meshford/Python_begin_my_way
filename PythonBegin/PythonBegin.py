ANumЬer = float ( input ("Введите число: " ))
print ( "Bы ввели: ", ANumЬer)
if ANumЬer==5:
    print("it's 5")
    print("end of blocks")
if ANumЬer==2 or ANumЬer==3:
    print("it`s 2 or it`s 3")
else:
    print("you are in blocks else")
#тут нет switch поэтому надо пользоваться elif
print ("l. Красный" )
print ("2. Оран:zевый" )
print (" З. ЖеЛтЬIЙ" )
print ("4. зеленый" )
print ("S. Синий" )
print ( "б. ПурпурlнЪIЙ ")
Choice = int ( input ( "ВЪlбepитe ваш цвет: " ))
if (Choice==1):
     print ( "ВЫ выбрали красный цвет!" )
elif (Choice == 2):
     print ( "Вы выбрали ораюrевый цве'l'! " )
elif (Choice == 3 ):
     print ( "ВЫ выбрали хе .'!ТЬIЙ цвет 1 " )
elif (Choice ==4 ):
     print ( "Bы выбрали sе.леный цвет!" )
elif (Choice == 5 ):
     print (" Вы выбрали синий цвеrr 1 " )
elif (Choice == 6 ):
     print (" ВЫ JЭJ,!брали nypnypныi< цsетl" )
else :
     print ( "Вы сделали неверный выбор 1 " )
#блоки в этом языке создаются остутпами
#циклы.....
LetterNum = 1
for Letter in "Привет":
    print("Бyквa ", LetterNum, "будет", Letter)
    LetterNum+=1
#в питоне есть проверка на пустоту "массива"
Value = input("Введите менее 6 символов: ")
LetterNum= 1
for Letter in Value:
     print ("Буква ", LetterNum, " будет ", Letter)
     LetterNum+=1
else:
    print("Cтpoкa пуста.")
#else  позволяет выполнять код, даже
#когда в заданной последовательности нет ни одного элемента для обработки.
#Приложение перечислит каждый символ в строке (см. рис. 9.2). Как ни странно,
#сообщение о том, что строка пустая, тоже будет выведено. Дело в том, что
#при нормальном завершении цикла for (т.е. без вызова инструкции break)
#ветвь else всегда выполняется.

#цикл while
Sum = 0
while Sum < 5:
    print(Sum)
    Sum+=1
#исключения
try:
    Value = int(input("Bвeдитe число от 1 до 10: "))
except ValueError:
    print("Hyжнo ввести число от 1 до 10!")
else:
    if (Value > 0) and (Value <= 10):
        print("Bы ввели: ", Value)
    else:
        рrint("Введенное значение некорректно!")
"""
Инструкция в блоке try может сгенерировать исключение, которое будет
обработано. В данном случае исключение возникает при получении
данных от пользователя с помощью вызова int (input ()).Исключения,
возникающие за пределами этого блока, не обрабатываются. У вас может
возникнуть соблазн заключить весь исполняемый код в блок try и тем
самым обрабатывать каждое исключение. Но на практике код обработки
делают максимально компактным и конкретным, чтобы четко локализо-
вать источник проблемы.
В нашем примере блок except перехватывает одно конкретное исключение:
ValueError. Оно будет сгенерировано и обработано, когда пользователь
введет строку, например Hello, вместо числового значения.
Другие исключения, сгенерированные каким-то иным способом, не будут
обрабатываться в данном блоке except.
Блок else содержит код, который выполняется, когда блок try завершается
успешно (не генерируя исключение). Этот код не должен выполняться, если
пользователь вводит некорректные данные. Когда пользователь вводит целое
число, программа проверяет, попадает ли число в заданный диапазон.
"""

"""
Использование предложения except без указания исключения
Можно создать обобщенный блок обработки исключений в Python, который
будет предназначен для перехвата любых исключений. Чаще всего мы перехватываем
конкретные исключения, руководствуясь следующими соображениями:
)) чтобы не пропустить исключение, которое не было учетно при разработке
приложения;
)) чтобы другие пользователи точно знали, какие именно исключения
обрабатывает ваше приложение;
)) чтобы корректно обработать исключение, используя специально
предназначенный для него код.
Но иногда требуется именно универсальный обработчик, например при использовании
сторонних библиотек или взаимодействии с внешними службами.
"""
#Порядок расположения обработчиков исключений важен (позднее всех default)
try:
    Value = int(input("Bвeдитe число от 1 до 10: "))
except ValueError:
    print("Hyжнo ввести число от 1 до 10!")
except:
    рrint("Обобщенная ошибка!")
else:
     if (Value > 0) and (Value <= 10):
       print("Bы ввели: ", Value)
     else:
       рrint("Введенное значение некорректно!")
#Единственное отличие от предыдущего примера заключается в появлении
#предложения except, не связанного с исключением ValueError. В результате
#это предложение
#если есть нескоолько ичключений их можно запихнуть в одни ексепт,а можно разделить на несколько
try:
    Valuel=int(input("Bвeдитe первое число: "))
    Value2=int(input("Bвeдитe второе число: "))
    Output=Valuel / Value2
except ValueError:
     print("Hyжнo ввести целое число!")
except Keyboardinterrupt:
     print("Bы нажали клавиши Ctrl+C!")
except ZeroDivisionError:
     рrint("Попытка деления на нуль 1 ")
except ArithmeticError:
     рrint("Произошла непредвиденная математическая ошибка.")
else:
     print(Output)
#тут порядок важен в исключениях!

"""
ВЛОЖЕННЫЕ ИСКЛБЧЕНИЯ
Иногда обработчик одного исключения необходимо расположить внутри
другого обработчика. Это называется вложение.и исключе11ий. При вложении
обработчиков Python сначала пытается найти обработчик на вложенном уровне,
а затем - на внешнем. Глубина вложений может быть произвольной.
"""
TryAgain = True
while TryAgain:
     try:
       Value = int(input("Bвeдитe целое число."))
     except ValueError:
       print("Hyжнo ввести целое число 1 ")
       try:
          DoOver = inрut("Попытаться снова (y/n)? ")
       except:
          print("Xopoшo, увидимся в следующий раз!")
          TryAgain = False
       else:
          if (str.upper(DoOver)== "N"):
               TryAgain = False
     except Keyboardinterrupt:
            print("Bы нажали клавиши Ctrl+C!")
            print ("Увидимся в следующий раз!")
            TryAgain = False
     else:
            print(Value)
            TryAgain = False
#сука ебучие блоки нахуй с табами




